---
import '@fontsource/calistoga';
import '@fontsource/pt-sans';

import Example from '../content/docs/Example.svelte';
import Demo from '../components/demo.svelte';

import { Code, Tabs, TabItem } from '@astrojs/starlight/components';

const sheepdogSvelteDemoCode = `
<script>
	import { task, timeout } from '@sheepdog/svelte';
	
	let searchTask = task.restart(async function(value) {
		await timeout(500);
		let response = await fetch('/my-favourite-sheep?search=' + value);
		return await response.json();
	});
</script>

<label for="search">Search</label>
<input
	name="search"
	type="text"
	on:input={(event) => searchTask.perform(event.target.value)}
/>

{#if $searchTask.isRunning}
	Loading...
{:else if $searchTask.lastSuccessful?.value.length}
	<ul>
		{#each $searchTask.lastSuccesful.value as name}
			<li>{name}</li>
		{/each}
	</ul>
{:else}
	No sheep found
{/if}
`;

const nativeSvelteDemoCode = `
<script>
	let _currentValue;
	let timeout;
	let search = (value) => {
		if (timeout) {
			clearTimeout(timeout);
		}
	
		let _timeout = setTimeout(async () => {
			let response = await fetch('/my-favourite-sheep?search=' + value);
			let results = await response.json();
			// only set results if this is the last started search
			if (timeout === _timeout) {
				currentValue = results;
				timeout = undefined;
			}
		}, 500);
		timeout = _timeout;
	};

	$: isRunning = Boolean(timeout);
	$: currentValue = _currentValue;
</script>

<label for="search">Search</label>
<input
	name="search"
	type="text"
	on:input={(event) => search(event.target.value)}
/>

{#if timeout}
	Loading...
{:else if currentValue?.length}
	<ul>
		{#each currentValue as name}
			<li>{name}</li>
		{/each}
	</ul>
{:else}
	No sheep found
{/if}
`;

const sheepdogVanillaDemoCode = `
import { task, timeout } from "@sheepdog/vanilla";

const container = document.getElementById('search-container');
container.innerHTML = \`
		<label for="search">Search</label>
		<input name="search" type="text" />
		<div id="output"></div>
	\`;

const searchInput = container.querySelector('input[name="search"]');
const outputContainer = container.querySelector('#output');

const search = task(
	async function* (value) {
		yield timeout(500);
		const response = yield fetch('/my-favourite-sheep?search=' + value);
		if (!response.ok) {
			throw new Error(\`HTTP error! status: \${response.status}\`);
		}
		return yield response.json();
	},
	{ kind: 'restart' }
);

search.on('start', () => {
	outputContainer.innerHTML = 'Loading...';
});

search.on('error', () => {
	outputContainer.innerHTML = 'There was an error';
});

search.on('instance-success', () => {
	const value = search.lastSuccessful.value
	outputContainer.innerHTML =
		value && value.length
			? \`
		<ul>
			\${value.map((name) => \`<li>\${name}</li>\`).join('')}
		</ul>
	\`
			: 'No sheep found';
});

searchInput.addEventListener('input', (event) => { 
	search.perform(event.target.value);
})
`;

const nativeVanillaDemoCode = `
let timeout;
let currentValue;
let isRunning = false;

const container = document.getElementById('search-container');
container.innerHTML = \`
	<label for="search">Search</label>
	<input name="search" type="text" />
	<div id="output"></div>
\`
const searchInput = container.querySelector('input[name="search"]');
const outputContainer = container.querySelector('#output')

const search = (value) => {
	if (timeout) {
		clearTimeout(timeout);
	}

	const _timeout = setTimeout(async () => {
		try {
			const response = await fetch('/my-favourite-sheep?search=' + value);
			if (!response.ok) {
				throw new Error(\`HTTP error! status: \${response.status}\`);
			}
			const results = await response.json();

			if (timeout === _timeout) {
				currentValue = results;
				timeout = undefined;
				isRunning = false;
				render();
			}
		} catch (error) {
			console.error('Error fetching sheep:', error);
			currentValue = null;
			timeout = undefined;
			isRunning = false;
			render();
		}
	}, 500);
	timeout = _timeout;
	isRunning = true;
	render();
};

const render = () => {
	outputContainer.innerHTML = isRunning ? 'Loading...' : currentValue && currentValue.length ? \`
		<ul>
			\${currentValue.map(name => \`<li>\${name}</li>\`).join('')}
		</ul>
	\` : 'No sheep found';
};

searchInput.addEventListener('input', (event) => search(event.target.value));

render();
`;
---

<section class="description">
	<h2>Task management made simple</h2>
	<p>
		Sheepdog helps you maintain your async tasks and gives you useful derived state in your Svelte
		app.
	</p>
	<p><i>Because managing tasks shouldn't feel like chasing sheep.</i></p>
</section>
<section class="demo">
	<div>
		<div>
			<h3>Code</h3>
		</div>
		<div class="tabbed-code-wrapper">
			<Tabs>
				<TabItem label="Svelte">
					<Tabs>
						<TabItem label="Sheepdog">
							<Code lang="svelte" code={sheepdogSvelteDemoCode} />
						</TabItem>
						<TabItem label="Native">
							<Code lang="svelte" code={nativeSvelteDemoCode} />
						</TabItem>
					</Tabs>
				</TabItem>
				<TabItem label="Vanilla">
					<Tabs>
						<TabItem label="Sheepdog">
							<Code lang="javascript" code={sheepdogVanillaDemoCode} />
						</TabItem>
						<TabItem label="Native">
							<Code lang="javascript" code={nativeVanillaDemoCode} />
						</TabItem>
					</Tabs>
				</TabItem>
			</Tabs>
		</div>
	</div>
	<div>
		<h3>Demo</h3>
		<div>
			<Demo client:load />
		</div>
	</div>
</section>

<section class="task-modifiers">
	<h2>Task modifiers</h2>
	<p>Specify what your task should do if there's another instance already running.</p>

	<Example show_tabs={true} client:load />
</section>

<style>
	:root {
		--sl-color-white: #f9f0e3;
		--sl-color-black: #3c3835;
		--sl-color-text-accent: var(--sl-color-white);
	}
	:root[data-theme='light'] {
		--sl-color-black: #f9f0e3;
		--sl-color-text-accent: var(--sl-color-white);
	}

	:global(body) {
		font-family: 'PT Sans', sans-serif;
		font-weight: 400;
		font-style: normal;
	}

	:global(h1, h2, h3, h4, h5, h6) {
		font-family: 'Calistoga', serif !important;
		font-weight: 400;
		font-style: normal;
	}

	.description {
		margin-bottom: 4rem;
	}

	.description p + p {
		margin-top: 0.5rem;
	}

	.demo {
		width: 100%;
		margin-bottom: 100px;
	}

	@media (min-width: 768px) {
		.demo {
			display: grid;
			grid-template-columns: 65% 35%;
			gap: 2rem;
		}

		.demo > div {
			margin-top: 0 !important;
		}
	}

	.tabbed-code-wrapper {
		position: relative;
		border: 2px solid var(--sl-color-white);
		border-radius: 1.25rem;
	}

	.tabbed-code-wrapper :global(.tablist-wrapper) {
		position: absolute;
		top: 0;
		left: 0;
		display: flex;
		justify-content: end;
		margin-top: -2px;
		margin-right: -2px;
	}

	.tabbed-code-wrapper :global([role='tabpanel'] .tablist-wrapper) {
		left: unset;
		right: 0;
	}

	.tabbed-code-wrapper :global([role='tabpanel']) {
		margin-top: 2.5rem;
	}

	.tabbed-code-wrapper :global(.tablist-wrapper ul) {
		border: 2px solid var(--sl-color-white);
		border-radius: 1.5rem;
	}

	.tabbed-code-wrapper :global(.tablist-wrapper li) {
		margin: 0;
	}

	.tabbed-code-wrapper :global(.tablist-wrapper a[role='tab']) {
		border: none;
		padding: 0.25rem 1.5rem;
		border-radius: 1.5rem;
		color: var(--sl-color-text);
		font-weight: bold;
	}

	.tabbed-code-wrapper :global(.tablist-wrapper a[role='tab'][aria-selected='true']) {
		background: var(--sl-color-white);
		color: var(--sl-color-text-invert);
	}

	.tabbed-code-wrapper :global(.expressive-code .frame) {
		box-shadow: none;
	}

	.tabbed-code-wrapper :global(.expressive-code .frame pre) {
		border: none;
		background: none;
	}

	.task-modifiers {
		max-width: 600px;
		margin: 0 auto;
	}
</style>
